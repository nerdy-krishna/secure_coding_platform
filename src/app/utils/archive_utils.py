import logging                                                                                                                                                                                                     
import os                                                                                                                                                                                                          
import shutil                                                                                                                                                                                                      
import tarfile                                                                                                                                                                                                     
import tempfile                                                                                                                                                                                                    
import zipfile                                                                                                                                                                                                     
from typing import List, Dict, Any, Optional                                                                                                                                                                       
                                                                                                                                                                                                                   
from fastapi import UploadFile, HTTPException                                                                                                                                                                      
                                                                                                                                                                                                                   
# Assuming get_language_from_filename can be imported from git_utils
# If this causes circular dependency issues or feels misplaced,
# it should be moved to a more general location.
from app.utils.file_utils import get_language_from_filename # UPDATED IMPORT

logger = logging.getLogger(__name__)
                                                                                                                                                                                                                   
# Configuration for archive extraction security                                                                                                                                                                    
# These could be moved to settings if more dynamic configuration is needed                                                                                                                                         
MAX_UNCOMPRESSED_SIZE_BYTES = 100 * 1024 * 1024  # 100 MB                                                                                                                                                          
MAX_FILES_IN_ARCHIVE = 1000                                                                                                                                                                                        
ALLOWED_ARCHIVE_EXTENSIONS = (                                                                                                                                                                                     
    ".zip",                                                                                                                                                                                                        
    ".tar.gz",                                                                                                                                                                                                     
    ".tgz",                                                                                                                                                                                                        
    ".tar.bz2",                                                                                                                                                                                                    
    ".tbz2",                                                                                                                                                                                                       
    ".tar.xz",                                                                                                                                                                                                     
    ".txz",                                                                                                                                                                                                        
    ".tar",                                                                                                                                                                                                        
)                                                                                                                                                                                                                  
                                                                                                                                                                                                                   
                                                                                                                                                                                                                   
def _is_path_safe(base_dir: str, target_path_within_archive: str) -> bool:                                                                                                                                         
    """                                                                                                                                                                                                            
    Checks if extracting target_path_within_archive into base_dir is safe                                                                                                                                          
    (i.e., does not traverse outside base_dir).                                                                                                                                                                    
    """                                                                                                                                                                                                            
    abs_base_dir = os.path.abspath(base_dir)                                                                                                                                                                       
    # Create the prospective absolute path of the extracted file                                                                                                                                                   
    abs_target_path = os.path.abspath(os.path.join(base_dir, target_path_within_archive))                                                                                                                          
    # Check if the prospective absolute path is still within the base directory                                                                                                                                    
    return abs_target_path.startswith(abs_base_dir)                                                                                                                                                                
                                                                                                                                                                                                                   
                                                                                                                                                                                                                   
def _sanitize_extracted_content(content_bytes: bytes) -> str:                                                                                                                                                      
    """                                                                                                                                                                                                            
    Decodes content bytes to string, attempting UTF-8 then latin-1,                                                                                                                                                
    and removes null bytes.                                                                                                                                                                                        
    """                                                                                                                                                                                                            
    try:                                                                                                                                                                                                           
        content_str = content_bytes.decode("utf-8")                                                                                                                                                                
    except UnicodeDecodeError:                                                                                                                                                                                     
        logger.warning("Could not decode file content as UTF-8, attempting latin-1.")                                                                                                                              
        try:                                                                                                                                                                                                       
            content_str = content_bytes.decode("latin-1")                                                                                                                                                          
        except UnicodeDecodeError as e:                                                                                                                                                                            
            logger.error(f"Failed to decode file content with UTF-8 and latin-1: {e}")                                                                                                                             
            raise HTTPException(                                                                                                                                                                                   
                status_code=400,                                                                                                                                                                                   
                detail=f"File content encoding not supported (tried UTF-8, latin-1). Error: {e}",                                                                                                                  
            )                                                                                                                                                                                                      
    return content_str.replace("\x00", "")                                                                                                                                                                         
                                                                                                                                                                                                                   
                                                                                                                                                                                                                   
def extract_archive_to_files(archive_file: UploadFile) -> List[Dict[str, Any]]:                                                                                                                                    
    """                                                                                                                                                                                                            
    Extracts files from an uploaded archive (zip or tarball) securely.                                                                                                                                             
                                                                                                                                                                                                                   
    Args:                                                                                                                                                                                                          
        archive_file: The UploadFile object representing the archive.                                                                                                                                              
                                                                                                                                                                                                                   
    Returns:                                                                                                                                                                                                       
        A list of dictionaries, where each dictionary represents a file                                                                                                                                            
        with 'path', 'content', and 'language'.                                                                                                                                                                    
                                                                                                                                                                                                                   
    Raises:                                                                                                                                                                                                        
        HTTPException if the archive is unsupported, unsafe, or exceeds limits.                                                                                                                                    
    """                                                                                                                                                                                                            
    if not archive_file.filename:                                                                                                                                                                                  
        raise HTTPException(status_code=400, detail="Archive filename is missing.")                                                                                                                                
                                                                                                                                                                                                                   
    file_extension = "".join(                                                                                                                                                                                      
        [suffix for suffix in archive_file.filename.lower().split(".") if suffix]                                                                                                                                  
    )                                                                                                                                                                                                              
    # More robust extension check for multi-part extensions like .tar.gz                                                                                                                                           
    filename_lower = archive_file.filename.lower()                                                                                                                                                                 
    is_supported_archive = False                                                                                                                                                                                   
    for ext in ALLOWED_ARCHIVE_EXTENSIONS:                                                                                                                                                                         
        if filename_lower.endswith(ext):                                                                                                                                                                           
            is_supported_archive = True                                                                                                                                                                            
            file_extension = ext # Use the matched extension for clarity                                                                                                                                           
            break                                                                                                                                                                                                  
                                                                                                                                                                                                                   
    if not is_supported_archive:                                                                                                                                                                                   
        raise HTTPException(                                                                                                                                                                                       
            status_code=400,                                                                                                                                                                                       
            detail=f"Unsupported archive format for file: {archive_file.filename}. "                                                                                                                               
                   f"Supported formats: {', '.join(ALLOWED_ARCHIVE_EXTENSIONS)}",                                                                                                                                  
        )                                                                                                                                                                                                          
                                                                                                                                                                                                                   
    extracted_files_data: List[Dict[str, Any]] = []                                                                                                                                                                
    total_uncompressed_size = 0                                                                                                                                                                                    
    file_count = 0                                                                                                                                                                                                 
                                                                                                                                                                                                                   
    with tempfile.TemporaryDirectory() as temp_dir:                                                                                                                                                                
        archive_path = os.path.join(temp_dir, archive_file.filename)                                                                                                                                               
        try:                                                                                                                                                                                                       
            with open(archive_path, "wb") as f_out:                                                                                                                                                                
                shutil.copyfileobj(archive_file.file, f_out)                                                                                                                                                       
        except Exception as e:                                                                                                                                                                                     
            logger.error(f"Failed to save uploaded archive: {e}")                                                                                                                                                  
            raise HTTPException(status_code=500, detail="Error saving uploaded archive.")                                                                                                                          
        finally:                                                                                                                                                                                                   
            archive_file.file.close() # Ensure the UploadFile stream is closed                                                                                                                                     
                                                                                                                                                                                                                   
        extraction_target_dir = os.path.join(temp_dir, "extracted_content")                                                                                                                                        
        os.makedirs(extraction_target_dir, exist_ok=True)                                                                                                                                                          
                                                                                                                                                                                                                   
        try:                                                                                                                                                                                                       
            if file_extension == ".zip":                                                                                                                                                                           
                with zipfile.ZipFile(archive_path, "r") as zf:                                                                                                                                                     
                    for member_info in zf.infolist():                                                                                                                                                              
                        if member_info.is_dir():                                                                                                                                                                   
                            continue  # Skip directories                                                                                                                                                           
                                                                                                                                                                                                                   
                        file_count += 1                                                                                                                                                                            
                        if file_count > MAX_FILES_IN_ARCHIVE:                                                                                                                                                      
                            raise HTTPException(                                                                                                                                                                   
                                status_code=400,                                                                                                                                                                   
                                detail=f"Archive contains too many files (limit: {MAX_FILES_IN_ARCHIVE}).",                                                                                                        
                            )                                                                                                                                                                                      
                                                                                                                                                                                                                   
                        total_uncompressed_size += member_info.file_size                                                                                                                                           
                        if total_uncompressed_size > MAX_UNCOMPRESSED_SIZE_BYTES:                                                                                                                                  
                            raise HTTPException(                                                                                                                                                                   
                                status_code=400,                                                                                                                                                                   
                                detail=f"Archive uncompressed size exceeds limit ({MAX_UNCOMPRESSED_SIZE_BYTES // (1024*1024)} MB).",                                                                              
                            )                                                                                                                                                                                      
                                                                                                                                                                                                                   
                        if not _is_path_safe(extraction_target_dir, member_info.filename):                                                                                                                         
                            logger.warning(                                                                                                                                                                        
                                f"Skipping potentially unsafe path in ZIP: {member_info.filename}"                                                                                                                 
                            )                                                                                                                                                                                      
                            continue                                                                                                                                                                               
                                                                                                                                                                                                                   
                        # Extract then read                                                                                                                                                                        
                        try:                                                                                                                                                                                       
                            # Ensure target directory for the file exists                                                                                                                                          
                            member_extract_path = os.path.join(extraction_target_dir, member_info.filename)                                                                                                        
                            os.makedirs(os.path.dirname(member_extract_path), exist_ok=True)                                                                                                                       
                            zf.extract(member_info, path=extraction_target_dir)                                                                                                                                    
                                                                                                                                                                                                                   
                            with open(member_extract_path, "rb") as extracted_f:                                                                                                                                   
                                content_bytes = extracted_f.read()                                                                                                                                                 
                        except Exception as e:                                                                                                                                                                     
                            logger.error(f"Error extracting/reading file {member_info.filename} from zip: {e}")                                                                                                    
                            continue # Skip this file                                                                                                                                                              
                                                                                                                                                                                                                   
                        content_str = _sanitize_extracted_content(content_bytes)                                                                                                                                   
                        language = get_language_from_filename(member_info.filename)                                                                                                                                
                        extracted_files_data.append({                                                                                                                                                              
                            "path": member_info.filename,                                                                                                                                                          
                            "content": content_str,                                                                                                                                                                
                            "language": language or "unknown",                                                                                                                                                     
                        })                                                                                                                                                                                         
                                                                                                                                                                                                                   
            elif file_extension.startswith(".tar") or file_extension == ".tgz" or file_extension == ".tbz2" or file_extension == ".txz":                                                                           
                # tarfile.open can handle .tar, .tar.gz, .tar.bz2, .tar.xz automatically                                                                                                                           
                with tarfile.open(archive_path, "r:*") as tf:                                                                                                                                                      
                    for member_info in tf.getmembers():                                                                                                                                                            
                        if not member_info.isfile():  # Process only regular files                                                                                                                                 
                            continue                                                                                                                                                                               
                                                                                                                                                                                                                   
                        file_count += 1                                                                                                                                                                            
                        if file_count > MAX_FILES_IN_ARCHIVE:                                                                                                                                                      
                            raise HTTPException(                                                                                                                                                                   
                                status_code=400,                                                                                                                                                                   
                                detail=f"Archive contains too many files (limit: {MAX_FILES_IN_ARCHIVE}).",                                                                                                        
                            )                                                                                                                                                                                      
                                                                                                                                                                                                                   
                        total_uncompressed_size += member_info.size                                                                                                                                                
                        if total_uncompressed_size > MAX_UNCOMPRESSED_SIZE_BYTES:                                                                                                                                  
                            raise HTTPException(                                                                                                                                                                   
                                status_code=400,                                                                                                                                                                   
                                detail=f"Archive uncompressed size exceeds limit ({MAX_UNCOMPRESSED_SIZE_BYTES // (1024*1024)} MB).",                                                                              
                            )                                                                                                                                                                                      
                                                                                                                                                                                                                   
                        if not _is_path_safe(extraction_target_dir, member_info.name):                                                                                                                             
                            logger.warning(                                                                                                                                                                        
                                f"Skipping potentially unsafe path in TAR: {member_info.name}"                                                                                                                     
                            )                                                                                                                                                                                      
                            continue                                                                                                                                                                               
                                                                                                                                                                                                                   
                        try:                                                                                                                                                                                       
                            # Extract then read                                                                                                                                                                    
                            # Ensure target directory for the file exists                                                                                                                                          
                            member_extract_path = os.path.join(extraction_target_dir, member_info.name)                                                                                                            
                            os.makedirs(os.path.dirname(member_extract_path), exist_ok=True)                                                                                                                       
                                                                                                                                                                                                                   
                            # Extract file object                                                                                                                                                                  
                            extracted_fo = tf.extractfile(member_info)                                                                                                                                             
                            if extracted_fo:                                                                                                                                                                       
                                with extracted_fo as f:                                                                                                                                                            
                                    content_bytes = f.read()                                                                                                                                                       
                                # Save to disk to be consistent with zip logic, or read directly                                                                                                                   
                                # For now, let's keep it consistent with reading from extracted file on disk                                                                                                       
                                with open(member_extract_path, "wb") as disk_f:                                                                                                                                    
                                    disk_f.write(content_bytes)                                                                                                                                                    
                            else:                                                                                                                                                                                  
                                # Should not happen if member_info.isfile() is true and no error                                                                                                                   
                                logger.warning(f"Could not extract file object for {member_info.name} from tar.")                                                                                                  
                                continue                                                                                                                                                                           
                        except Exception as e:                                                                                                                                                                     
                            logger.error(f"Error extracting/reading file {member_info.name} from tar: {e}")                                                                                                        
                            continue # Skip this file                                                                                                                                                              
                                                                                                                                                                                                                   
                        content_str = _sanitize_extracted_content(content_bytes)                                                                                                                                   
                        language = get_language_from_filename(member_info.name)                                                                                                                                    
                        extracted_files_data.append({                                                                                                                                                              
                            "path": member_info.name,                                                                                                                                                              
                            "content": content_str,                                                                                                                                                                
                            "language": language or "unknown",                                                                                                                                                     
                        })                                                                                                                                                                                         
            else:                                                                                                                                                                                                  
                # This case should be caught by the initial extension check                                                                                                                                        
                raise HTTPException(status_code=400, detail="Internal error: Unhandled archive type.")                                                                                                             
                                                                                                                                                                                                                   
        except HTTPException: # Re-raise HTTPExceptions                                                                                                                                                            
            raise                                                                                                                                                                                                  
        except Exception as e:                                                                                                                                                                                     
            logger.error(f"Error processing archive {archive_file.filename}: {e}", exc_info=True)                                                                                                                  
            raise HTTPException(status_code=500, detail=f"Error processing archive: {str(e)}")                                                                                                                     
                                                                                                                                                                                                                   
    if not extracted_files_data:                                                                                                                                                                                   
        raise HTTPException(                                                                                                                                                                                       
            status_code=400,                                                                                                                                                                                       
            detail="No processable files found in the archive or all files were skipped.",                                                                                                                         
        )                                                                                                                                                                                                          
    return extracted_files_data                                                                                                                                                                                    
                                                                                                                                                                                                                   
def is_archive_filename(filename: Optional[str]) -> bool:                                                                                                                                                          
    """                                                                                                                                                                                                            
    Checks if a filename likely belongs to an archive based on its extension.                                                                                                                                      
    """                                                                                                                                                                                                            
    if not filename:                                                                                                                                                                                               
        return False                                                                                                                                                                                               
    filename_lower = filename.lower()                                                                                                                                                                              
    for ext in ALLOWED_ARCHIVE_EXTENSIONS:                                                                                                                                                                         
        if filename_lower.endswith(ext):                                                                                                                                                                           
            return True                                                                                                                                                                                            
    return False
